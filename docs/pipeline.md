重要１

始める前に、以下のコマンドでMLパイプライントレーニング用のデータをダウンロードしてください。

```
$ wget http://d12yw77jruda6f.cloudfront.net/ampcamp-pipelines.zip
$ unzip ampcamp-pipelines.zip
```

この章では、試作バージョンのMLパイプラインを使ってイメージ解析機を構築したいと思います。
このアプリケーションの目的はある入力イメージ（写真）を、自動的に何が写されているかを判断することです。
鳥の写真は「トリ」のクラスを出力するはずです。
イメージ解析はこのパイプラインフレームワークでサポートされる一つのアプリケーションとされますが、このエクササイズが終わるころにはほかの応用法があると感じてもらいたいです。

解析タスクの詳細に行く前に、プロジェクトの目的とフレームワークの原則を軽くおさらいしましょう。

# 7-1. パイプラインフレームワーク
パイプラインプロジェクトの最終地点は　1)特徴を読み取る作業で使うフレームワークと　2)その複雑な学習機能を簡潔で使い勝手の良い部品から組み立てるモジュール式の機械学習として提供することです。
構築後のパイプラインは潜在的に複雑な入力データの前処理と予想過程をエンドユーザから見てわかりやすい方法で提示します。
言い直すと、一式のパイプラインは私が写真、音声、テキスト、ログなどの様々なデータを入れた際に正体を予想してくれるブラックボックスです。

パイプラインの内臓はエンドユーザに透明で解りやすいほうがいいですが、パイプラインを構築する側は明確に理解していなければいけません。
今回、あなたはパイプライン構築家になってもらいます。

あなかが使うパイプラインフレームワークは数個のシンプルな原則に基づいています。

- パイプラインは入力タイプと出力タイプを求めるノードたちから出来ています。
- 前のノードの出力タイプと次のノードの入力タイプが合っていないと組み立てられません。
- パイプライン自体もノードと考えることができて、それらを組み合わせることのよって新たなパイプラインが作成できます。
- ノードは出来る限りRDDを入力して、RDDを生産し出力します。なので、開発者は並列データ　　処理を頭に入れなければいけません。

このタイプセーフなアプローチによって、パイプラインを現実的な時間で組み立てることができ、作成したパイプラインを分散処理環境に展開することで発生する問題を最小化することができます。

今回扱うコードベースはAMPLabで構築された大きなシステムの重要な部分の試作版です。
これは以下に当てはまるノードを扱っています。

- 特徴摘出とデータ処理を行うイメージ処理
- データ正規化や拡大縮小（スケーリング）などの一般的な統計変換
- モデルを訓練する線形ソルバー

これらに加えて役に立つ機能として、作成したパイプラインのセーブやロード、選別エラーの計算方法なども含まれています。
完全なるパイプラインのレポジトリは試作品ですが、準備ができましたら披露する予定です。


# 7-2. パイプラインAPI
このAPIは公共リーリスまでに変わっているかもしれません。ここで提示されるのは試作品です。

パイプラインAPIのコアは単純で、タイプセーフ機能のプログラミングを重点的にインスパイアされています。
以下がパイプラインノードとパイプラインの定義です。

```
object Pipelines {
  type PipelineNode[Input, Output] = (Input => Output)

  type Pipeline[Input, Output] = ((Input) => Output)
}
```

Scalaが慣れてない方に説明すると、パイプラインノードはInputの入力タイプとOutputの出力タイプを繋ぐ関数と同じインターフェースです。
パイプラインノードはただの関数と考えると良いでしょう。

新しいノードを定義する時は単純にこのインターフェースを実装するクラスを書きます。
具体的には、apply(x: Input):　Outputというメソッドを呼びます。
Scalaではこの入力タイプと出力タイプは抽象概念です。

見本のノードを見ていきましょう。

```
case object Vectorizer 
  extends PipelineNode[RDD[Image], RDD[Vector]]] 
  with Serializable {
  override def apply(in: RDD[Image]): RDD[Vector] = {
    in.map(_.toVector)
  }
}
```

このノードはRDD[Image]を入力として取り込み、RDD[Vector]を出力として作り出します。
この作業は「_.toVector」を入力の各エレメントに呼んで行われます。これは明確でかなり単純な実例です。
この方法はScalaのシンタックスを利用してパイプラインを構成するなどScala言語の幾つかの機能を扱うことができます。

例としてもし二つのノード（ベクトライザと１を各ベクトルの最初に加えるノード）から出来るパイプラインを作成したい場合、以下を書きます。

```
val pipeline = Vectorizer andThen InterceptAdder 
//パイプラインは RDD[Image]を入力し １が前列に加えられたRDD[Vector]を出力します

//データセットに応用する場合はこの様になります。
val x: RDD[Image] = sc.objectFile(someFileName)
val result = pipeline.apply(x) //結果はRDD[Vector]です
//それか同類の
val result = pipeline(x)
```

この例では、InterceptAdderがVectorとして入力を求めているから動きます。

パイプライン操作は基本的にRDDトランスフォーメーションなので、Sparkで自動的にスケジュールされて効率的に実行されます。
例えば、上の実例のパイプラインはアクションが結果に発動されるまで実行されません。
さらに、二つのノードの間にあるマップ（map)のタスクは自動的に一つのタスクとして押し出され実行されます。

今から、これらのアイデアがどのように並列されたデータセットに対して複雑な機械学習のタスクを行うのかを見ていきましょう。


# 7-3. データセット
coming soon
# 7-4. 線形選別
coming soon
# 7-5. セットアップ
coming soon
# 7-6. 簡単なパイプライン
coming soon
# 7-7. 改善後のパイプライン
coming soon
# 7-8. 上級パイプライン
coming soon
# 7-9. 訓練済みのパイプラインをロードする
coming soon
# 7-10. パイプライン評価
coming soon
# 7-11. パイプラインの評価
coming soon
# 7-12. 番外編
coming soon
